#!/bin/bash
Is called a shebang and determines what shell is used to interpret the script

ps -fp 9000
Examine the process with PID 9000

ps -ef
Show all the commands executed by the shell

Variables:
variableName="value"
Assign variable
variableName=$(command)
Assign the output of a command
variableName=`command`
Old syntax for assigning the output of a command
echo $variableName
Echo a variable
echo "$variableName"
Echo a variable as part of a string
echo "${variableName}"
Echo a variable as part of a string, with more control
Variables can have letters (upper and lower), digits, underscores. But not dashes, atsigns, or starting with digits

Tests:
A test is a conditional that checks if a value is true
[ condition-to-test-for ]
[ -e /etc/passwd ]
File operators:
-d FILE - file is a directory
-e FILE - file exists
-f FILE - file exists and is a regular file (not a symlink for example)
-r FILE - file is readable by you
-s FILE - file exists and is not empty
-w FILE - file is writable by you
-x FILE - file is executable by you
String operators:
-z STRING - string is empty
-n STRING - string is not empty
STRING1 = STRING2 - strings are equal
STRING1 != STRING2 - strings are not equal
Arithmetic operators:
arg1 -eq arg2
arg1 -ne arg2
arg1 -lt arg2
arg1 -le arg2
arg1 -gt arg2
arg1 -ge arg2

For loops:
Perform an action for a list of items

Arrays:
Define arrays like this:
varName=(1 2 3 "Test")

Exit status:
Every time a command is executed it returns an exit status (return code / exit code)
ranges from 0-255
0 = success
nonzero = error
nonzero error codes mean different things for different commands. They are not generalized.
Check the man page of a command to see what each error code means for that command
variable $? contains the exit code of the previously executed command
You can return an exit code by using the exit command. For example: exit 1
If you do not use exit, or you use it without a number, then the exit code of the last command is returned.

Using AND / OR to execute commands
if && is used, the next command will only execute if the previous command returns 0 exit code
if || is used, the next command will only execute if the previous command returns nonzero exit code
if ; is used, all commands will always run.

Redirections
echo "text" > file.txt
Sends text to the file
1> sends only stdout and is the default for >
2> sends only stderr
&> sends both stdout and stderr and can be used to completely silence a command. For example: ping -c 1 "$host" &> /dev/null
Finally, 0 would be stdin but is not relevant in this context.

Functions
There are two ways to define functions:
function function-name() {
    # Code goes here
}
function-name() {
    # Code goes here
}
To call a function, simply put the function's name on its own line. Do not use parentheses. For example:
function-name
A function must be defined before it is used. Order is relevant.

Variable scope
By default, variables are global (Except for positional parameters)
Using a variable before it is defined will just result in nothing
Local variables use function scope. Define them by putting local in front of the variable definition.
Only functions can have local variables.
Local variables are best practice.

Double quotes
Disables word splitting and most forms of expansion. Variable expansion is not disabled.

Brace expansion
Brace expansion causes a braced expression to be split into multiple parts. For example, echo a{d,c,b}e would echo "ade", "ace", and "abe"

Wildcards
A wildcard is a character or string used to match file and directory names
Wildcards create search patterns, which when expanded (globbing) create a list of matching results
Wildcards can be used with commands that accept a filename or directory.
* matches zero or more characters. In other words, anything.
? matches exactly one character.
[] matches exactly one character, but only from the characters inside the brackets (Character Class)
[!] matches exactly one character, but only from characters that are NOT inside the brackets
Ranges can also be used, like [a-g]
There are also predefined named character classes which can be used:
[[:alpha:]] - Matches letters [a-zA-Z]
[[:alnum:]] - Matches letters and digits [a-zA-Z0-9]
[[:digit:]] - Matches digits [0-9]
[[:lower:]] - Matches lowercase letters [a-z]
[[:space:]] - Matches whitespace
[[:upper:]] - Matches uppercase letters [A-Z]
If you want to match a character literally, use backslashes to escape it.

Case statements
Case statements allow you to check a variable against multiple values
Each value ends with a closing parenthesis, is followed by statements, and ends with two semicolons
Wildcards can also be used, so *) matches everything
Pipes can be used for OR, so start|START) matches either casing

Logging
The syslog standard uses facility codes and severity levels
Facilities: kern, user, mail, daemon, auth, local0-local7
For example, the kern facility is used for scripts in the kernel, the mail facility is used for scripts that have to do with sending or receiving mails.
If you are unsure which facility to use, you can use the user facility. The local0 through local7 facilities are custom facilities that can also be used for this purpose.
Severities levels from most to least severe: emerg, alert, crit, err, warning, notice, info, debug
Usually, messages are logged to a file. The file is configurable and changes per distribution.
Often used files are:
/var/log/messages
/var/log/syslog
The logger command can be used to log messages. By default it uses local0.info
My logging didn't work at first. I installed rsyslog (Check google for how to) and then ran this:
sudo /etc/init.d/rsyslog stop
sudo /etc/init.d/rsyslog start
Afterwards, it worked. Also, the files to log into can be configured by editing /etc/rsyslog.d/50-default.conf (Don't forget to restart rsyslog again once you've made a change)